"""Generate Terraform HCL files for unmanaged AWS resources.

Groups discovered-but-unmanaged resources by ``resource_type`` and renders a
dedicated ``.tf`` file for each group using inline Jinja2 templates.  The
generated files are written to the target Terraform directory and are clearly
marked as auto-generated so that humans do not edit them by hand.

**Important:** this module never modifies existing ``.tf`` files.  It only
creates *new* files whose names are prefixed with ``radix_managed_``.
"""

import os
import re
from typing import Dict, List

from jinja2 import BaseLoader, Environment

from ..models import DiscoveredResource

_HEADER = "# Auto-generated by radix-agent \u2014 do not edit manually"

# ---------------------------------------------------------------------------
# Jinja2 helper
# ---------------------------------------------------------------------------

_JINJA_ENV = Environment(
    loader=BaseLoader(),
    keep_trailing_newline=True,
    trim_blocks=True,
    lstrip_blocks=True,
)


def _sanitize(name: str) -> str:
    """Turn an arbitrary string into a Terraform-safe resource name."""
    safe = re.sub(r"[^a-zA-Z0-9]", "_", name)
    safe = re.sub(r"_+", "_", safe)
    return safe.strip("_").lower()


# ---------------------------------------------------------------------------
# Per-service HCL templates (inline Jinja2 strings)
# ---------------------------------------------------------------------------

_TEMPLATES: Dict[str, str] = {
    # ---- Route 53 ---------------------------------------------------------
    "aws_route53_zone": """\
{{ header }}

{% for r in resources %}
resource "aws_route53_zone" "{{ r.tf_name }}" {
  name = "{{ r.properties.get("name", r.name or r.resource_id) }}"

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    "aws_route53_record": """\
{{ header }}

{% for r in resources %}
resource "aws_route53_record" "{{ r.tf_name }}" {
  zone_id = "{{ r.properties.get("zone_id", "") }}"
  name    = "{{ r.properties.get("name", r.name or r.resource_id) }}"
  type    = "{{ r.properties.get("type", "A") }}"
  ttl     = {{ r.properties.get("ttl", 300) }}

  records = {{ r.properties.get("records", "[]") | tojson }}
}

{% endfor %}
""",
    # ---- CloudFront -------------------------------------------------------
    "aws_cloudfront_distribution": """\
{{ header }}

{% for r in resources %}
resource "aws_cloudfront_distribution" "{{ r.tf_name }}" {
  enabled         = {{ r.properties.get("enabled", true) | tojson }}
  is_ipv6_enabled = {{ r.properties.get("is_ipv6_enabled", true) | tojson }}
  comment         = "{{ r.properties.get("comment", r.name or r.resource_id) }}"

  origin {
    domain_name = "{{ r.properties.get("origin_domain", "PLACEHOLDER") }}"
    origin_id   = "{{ r.properties.get("origin_id", "default") }}"
  }

  default_cache_behavior {
    allowed_methods        = ["GET", "HEAD"]
    cached_methods         = ["GET", "HEAD"]
    target_origin_id       = "{{ r.properties.get("origin_id", "default") }}"
    viewer_protocol_policy = "redirect-to-https"

    forwarded_values {
      query_string = false
      cookies {
        forward = "none"
      }
    }
  }

  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }

  viewer_certificate {
    cloudfront_default_certificate = true
  }

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    # ---- API Gateway ------------------------------------------------------
    "aws_apigateway_rest_api": """\
{{ header }}

{% for r in resources %}
resource "aws_apigateway_rest_api" "{{ r.tf_name }}" {
  name        = "{{ r.properties.get("name", r.name or r.resource_id) }}"
  description = "{{ r.properties.get("description", "") }}"

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    # ---- ACM --------------------------------------------------------------
    "aws_acm_certificate": """\
{{ header }}

{% for r in resources %}
resource "aws_acm_certificate" "{{ r.tf_name }}" {
  domain_name       = "{{ r.properties.get("domain_name", r.name or r.resource_id) }}"
  validation_method = "{{ r.properties.get("validation_method", "DNS") }}"

  lifecycle {
    create_before_destroy = true
  }

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    # ---- ELB / ALB / NLB -------------------------------------------------
    "aws_lb": """\
{{ header }}

{% for r in resources %}
resource "aws_lb" "{{ r.tf_name }}" {
  name               = "{{ r.properties.get("name", r.name or r.resource_id) }}"
  internal           = {{ r.properties.get("internal", false) | tojson }}
  load_balancer_type = "{{ r.properties.get("load_balancer_type", "application") }}"

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    "aws_lb_target_group": """\
{{ header }}

{% for r in resources %}
resource "aws_lb_target_group" "{{ r.tf_name }}" {
  name     = "{{ r.properties.get("name", r.name or r.resource_id) }}"
  port     = {{ r.properties.get("port", 80) }}
  protocol = "{{ r.properties.get("protocol", "HTTP") }}"
  vpc_id   = "{{ r.properties.get("vpc_id", "PLACEHOLDER") }}"

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    "aws_lb_listener": """\
{{ header }}

{% for r in resources %}
resource "aws_lb_listener" "{{ r.tf_name }}" {
  load_balancer_arn = "{{ r.properties.get("load_balancer_arn", "PLACEHOLDER") }}"
  port              = {{ r.properties.get("port", 443) }}
  protocol          = "{{ r.properties.get("protocol", "HTTPS") }}"

  default_action {
    type             = "{{ r.properties.get("default_action_type", "forward") }}"
    target_group_arn = "{{ r.properties.get("target_group_arn", "PLACEHOLDER") }}"
  }

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    # ---- S3 ---------------------------------------------------------------
    "aws_s3_bucket": """\
{{ header }}

{% for r in resources %}
resource "aws_s3_bucket" "{{ r.tf_name }}" {
  bucket = "{{ r.properties.get("bucket", r.name or r.resource_id) }}"

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    # ---- SSM Parameter Store ----------------------------------------------
    "aws_ssm_parameter": """\
{{ header }}

{% for r in resources %}
resource "aws_ssm_parameter" "{{ r.tf_name }}" {
  name  = "{{ r.properties.get("name", r.name or r.resource_id) }}"
  type  = "{{ r.properties.get("type", "String") }}"
  value = "{{ r.properties.get("value", "PLACEHOLDER") }}"

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    # ---- Cognito ----------------------------------------------------------
    "aws_cognito_user_pool": """\
{{ header }}

{% for r in resources %}
resource "aws_cognito_user_pool" "{{ r.tf_name }}" {
  name = "{{ r.properties.get("name", r.name or r.resource_id) }}"

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    # ---- CloudWatch -------------------------------------------------------
    "aws_cloudwatch_log_group": """\
{{ header }}

{% for r in resources %}
resource "aws_cloudwatch_log_group" "{{ r.tf_name }}" {
  name              = "{{ r.properties.get("name", r.name or r.resource_id) }}"
  retention_in_days = {{ r.properties.get("retention_in_days", 14) }}

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
    # ---- ECR --------------------------------------------------------------
    "aws_ecr_repository": """\
{{ header }}

{% for r in resources %}
resource "aws_ecr_repository" "{{ r.tf_name }}" {
  name                 = "{{ r.properties.get("name", r.name or r.resource_id) }}"
  image_tag_mutability = "{{ r.properties.get("image_tag_mutability", "MUTABLE") }}"

  image_scanning_configuration {
    scan_on_push = {{ r.properties.get("scan_on_push", true) | tojson }}
  }

  tags = merge(local.common_tags, {
    Name = "{{ r.name or r.resource_id }}"
  })
}

{% endfor %}
""",
}


# ---------------------------------------------------------------------------
# Generator class
# ---------------------------------------------------------------------------

class TerraformGenerator:
    """Render Terraform HCL files for unmanaged resources.

    The generator groups resources by ``resource_type``, selects the
    appropriate inline Jinja2 template, and writes a new ``.tf`` file for
    each group.  Existing files are **never** modified; generated files are
    prefixed with ``radix_managed_`` to make them easy to identify.

    Parameters
    ----------
    tf_dir:
        Absolute path to the directory where generated ``.tf`` files will be
        written (typically the same ``infra/aws`` directory that holds the
        hand-written configuration).
    """

    def __init__(self, tf_dir: str) -> None:
        self.tf_dir = tf_dir

    def generate(self, unmanaged: List[DiscoveredResource]) -> Dict[str, int]:
        """Generate ``.tf`` files for *unmanaged* resources.

        Parameters
        ----------
        unmanaged:
            Resources that were discovered in the live account but have no
            matching ``resource_type`` in the existing Terraform configuration.

        Returns
        -------
        dict mapping filepath (str) to the number of resources written (int).
        """
        if not unmanaged:
            return {}

        # Group resources by type.
        grouped: Dict[str, List[DiscoveredResource]] = {}
        for resource in unmanaged:
            grouped.setdefault(resource.resource_type, []).append(resource)

        results: Dict[str, int] = {}

        for rtype, resources in sorted(grouped.items()):
            template_src = _TEMPLATES.get(rtype)
            if template_src is None:
                # No template for this resource type â€” skip silently.
                continue

            # Ensure each resource gets a unique, Terraform-safe name.
            seen_names: Dict[str, int] = {}
            enriched: List[dict] = []
            for r in resources:
                base = _sanitize(r.name or r.resource_id)
                if not base:
                    base = "unnamed"
                if base in seen_names:
                    seen_names[base] += 1
                    tf_name = f"{base}_{seen_names[base]}"
                else:
                    seen_names[base] = 0
                    tf_name = base

                enriched.append(
                    {
                        "tf_name": tf_name,
                        "resource_id": r.resource_id,
                        "arn": r.arn,
                        "name": r.name,
                        "tags": r.tags,
                        "properties": r.properties,
                    }
                )

            template = _JINJA_ENV.from_string(template_src)
            rendered = template.render(header=_HEADER, resources=enriched)

            # Derive a filesystem-safe filename from the resource type.
            type_suffix = rtype.replace("aws_", "", 1)
            filename = f"radix_managed_{type_suffix}.tf"
            filepath = os.path.join(self.tf_dir, filename)

            os.makedirs(self.tf_dir, exist_ok=True)
            with open(filepath, "w", encoding="utf-8") as fh:
                fh.write(rendered)

            results[filepath] = len(resources)

        return results

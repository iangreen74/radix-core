"""Generate a bash script that runs ``terraform import`` for unmanaged resources.

The script is self-contained: it sets strict shell options, initialises
Terraform in the target directory, and then executes one ``terraform import``
command per resource, using the correct import-ID format for each AWS resource
type.
"""

import re
from typing import Dict, List, Optional

from ..models import DiscoveredResource

# ---------------------------------------------------------------------------
# Import-ID resolvers
# ---------------------------------------------------------------------------
# Each entry maps a Terraform resource type to a callable that receives a
# ``DiscoveredResource`` and returns the string Terraform expects as the
# import ID.  When the callable returns ``None`` the resource is skipped
# (with a comment in the script explaining why).

def _id(r: DiscoveredResource) -> Optional[str]:
    """Fallback: use ``resource_id`` verbatim."""
    return r.resource_id or None


def _arn(r: DiscoveredResource) -> Optional[str]:
    return r.arn or None


def _zone_id(r: DiscoveredResource) -> Optional[str]:
    return r.properties.get("zone_id") or r.resource_id or None


def _route53_record(r: DiscoveredResource) -> Optional[str]:
    """Route 53 records are imported as ``zone_id_name_type``."""
    zone_id = r.properties.get("zone_id", "")
    name = r.properties.get("name", r.name or "")
    rtype = r.properties.get("type", "")
    if zone_id and name and rtype:
        return f"{zone_id}_{name}_{rtype}"
    return None


def _bucket_name(r: DiscoveredResource) -> Optional[str]:
    return r.properties.get("bucket") or r.name or r.resource_id or None


def _parameter_name(r: DiscoveredResource) -> Optional[str]:
    return r.properties.get("name") or r.name or r.resource_id or None


def _pool_id(r: DiscoveredResource) -> Optional[str]:
    return r.properties.get("pool_id") or r.resource_id or None


def _log_group_name(r: DiscoveredResource) -> Optional[str]:
    return r.properties.get("name") or r.name or r.resource_id or None


def _api_id(r: DiscoveredResource) -> Optional[str]:
    return r.properties.get("api_id") or r.resource_id or None


def _repo_name(r: DiscoveredResource) -> Optional[str]:
    return r.properties.get("name") or r.name or r.resource_id or None


def _distribution_id(r: DiscoveredResource) -> Optional[str]:
    return r.properties.get("distribution_id") or r.resource_id or None


_IMPORT_ID_MAP: Dict[str, object] = {
    "aws_route53_zone": _zone_id,
    "aws_route53_record": _route53_record,
    "aws_cloudfront_distribution": _distribution_id,
    "aws_acm_certificate": _arn,
    "aws_lb": _arn,
    "aws_lb_target_group": _arn,
    "aws_lb_listener": _arn,
    "aws_s3_bucket": _bucket_name,
    "aws_ssm_parameter": _parameter_name,
    "aws_cognito_user_pool": _pool_id,
    "aws_cloudwatch_log_group": _log_group_name,
    "aws_apigateway_rest_api": _api_id,
    "aws_ecr_repository": _repo_name,
}


# ---------------------------------------------------------------------------
# Name sanitiser (mirrors generator.py)
# ---------------------------------------------------------------------------

def _sanitize(name: str) -> str:
    """Turn an arbitrary string into a Terraform-safe resource name."""
    safe = re.sub(r"[^a-zA-Z0-9]", "_", name)
    safe = re.sub(r"_+", "_", safe)
    return safe.strip("_").lower()


# ---------------------------------------------------------------------------
# Script generator
# ---------------------------------------------------------------------------

class ImportScriptGenerator:
    """Produce a ready-to-run bash import script for unmanaged resources.

    The generated script:

    1. Uses ``set -euo pipefail`` for strict error handling.
    2. Changes into the Terraform directory.
    3. Runs ``terraform init``.
    4. Executes ``terraform import <address> <id>`` for every resource whose
       type has a known import-ID mapping.
    """

    def generate(self, unmanaged: List[DiscoveredResource], tf_dir: str) -> str:
        """Return the import script as a string.

        Parameters
        ----------
        unmanaged:
            Resources discovered in the live account that are not yet managed
            by Terraform.
        tf_dir:
            Path to the Terraform working directory (used for ``cd`` and
            ``terraform init``).

        Returns
        -------
        str
            A complete bash script.  If *unmanaged* is empty the script will
            still be valid but will contain only the header and init step.
        """
        lines: List[str] = [
            "#!/usr/bin/env bash",
            "# Auto-generated by radix-agent â€” do not edit manually",
            "#",
            "# This script imports unmanaged AWS resources into the Terraform state.",
            "# Review the generated .tf files before running this script.",
            "",
            "set -euo pipefail",
            "",
            f'cd "{tf_dir}"',
            "",
            'echo "==> Initialising Terraform..."',
            "terraform init",
            "",
        ]

        if not unmanaged:
            lines.append('echo "No resources to import."')
            return "\n".join(lines) + "\n"

        # Track names so we can produce the same unique suffixes as the
        # generator (they must match for the import addresses to be correct).
        seen_names: Dict[str, int] = {}
        # Group by type to keep the script ordered, matching generator output.
        grouped: Dict[str, List[DiscoveredResource]] = {}
        for r in unmanaged:
            grouped.setdefault(r.resource_type, []).append(r)

        for rtype in sorted(grouped):
            resolver = _IMPORT_ID_MAP.get(rtype)
            if resolver is None:
                lines.append(f"# Skipping {rtype}: no import-ID mapping defined")
                lines.append("")
                continue

            lines.append(f'echo "==> Importing {rtype} resources..."')

            # Reset per-type name tracking so names match the generator.
            type_seen: Dict[str, int] = {}

            for r in grouped[rtype]:
                base = _sanitize(r.name or r.resource_id)
                if not base:
                    base = "unnamed"
                if base in type_seen:
                    type_seen[base] += 1
                    tf_name = f"{base}_{type_seen[base]}"
                else:
                    type_seen[base] = 0
                    tf_name = base

                import_id = resolver(r)
                address = f"{rtype}.{tf_name}"

                if import_id is None:
                    lines.append(
                        f"# SKIP {address}: unable to determine import ID "
                        f"(resource_id={r.resource_id!r})"
                    )
                else:
                    lines.append(
                        f'terraform import "{address}" "{import_id}"'
                    )

            lines.append("")

        lines.append('echo "==> Import complete."')
        return "\n".join(lines) + "\n"
